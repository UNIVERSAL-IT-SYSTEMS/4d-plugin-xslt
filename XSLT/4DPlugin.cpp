/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.c
 #	source generated by 4D Plugin Wizard
 #	Project : XSLT
 #	author : miyako
 #	2014/08/13
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#include <string.h>

#include <libxml/xmlmemory.h>
#include <libxml/debugXML.h>
#include <libxml/HTMLtree.h>
#include <libxml/xmlIO.h>
#include <libxml/DOCBparser.h>
#include <libxml/xinclude.h>
#include <libxml/catalog.h>

#include <libxslt/xslt.h>
#include <libxslt/xsltInternals.h>
#include <libxslt/transform.h>
#include <libxslt/xsltutils.h>

void PluginMain(int32_t selector, PA_PluginParameters params)
{
	try
	{
		int32_t pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (int32_t pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin:
		case kServerInitPlugin:
			xmlSubstituteEntitiesDefault(1);//substitute entities
			xmlLoadExtDtdDefaultValue = 1;//load external entity subsets			
			break;			
// --- XSLT

		case 1 :
			XSLT_Apply_stylesheet(pResult, pParams);
			break;
			
		case kDeinitPlugin:
		case kServerDeinitPlugin:
			xsltCleanupGlobals();
			xmlCleanupParser();			
			break;			
	}
}

// ------------------------------------- XSLT -------------------------------------


void XSLT_Apply_stylesheet(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	
	ARRAY_TEXT Param3;
	ARRAY_TEXT Param4;
	
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);	
	
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);

#if VERSIONMAC
	Param1.convertPath();	
	Param2.convertPath();	
#endif

	CUTF8String xmlPath;
	Param1.copyUTF8String(&xmlPath);
	
	CUTF8String xslPath;
	Param2.copyUTF8String(&xslPath);	
	
	xsltStylesheetPtr cur = xsltParseStylesheetFile((const xmlChar *)xslPath.c_str());		
	if(cur){
		xmlDocPtr doc = xmlParseFile((const char *)xmlPath.c_str());
		if(doc){
			std::vector<CUTF8String> _params;
			std::vector<const char *> params;		
			if(Param3.getSize() == Param4.getSize()){
				unsigned int i, size = Param4.getSize();
				CUTF8String name, value;
				size_t j = 0;
				for(i = 0; i < size; ++i){
					Param3.copyUTF8StringAtIndex(&name, i);
					Param4.copyUTF8StringAtIndex(&value, i);	
					if(name.length() != 0){
						_params.push_back(name);
						_params.push_back(value);
						params.push_back((const char *)_params[j++].c_str());
						params.push_back((const char *)_params[j].c_str());
					}
				}
			}	
			params.push_back(NULL);
			
			xmlDocPtr res = xsltApplyStylesheet(cur, doc, &params[0]);
			if(res){
				xmlChar *buf;
				int len;
				if(!xsltSaveResultToString(&buf, &len, res, cur)){
					returnValue.setUTF8String((const uint8_t *)buf, len);
				}
				xmlFreeDoc(res);
			}
			xmlFreeDoc(doc);
		}
		xsltFreeStylesheet(cur);	
	}
	returnValue.setReturn(pResult);
}

